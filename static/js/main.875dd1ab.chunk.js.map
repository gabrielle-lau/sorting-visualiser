{"version":3,"sources":["SortingAlgorithms/MergeSort.js","SortingAlgorithms/HeapSort.js","Caption.jsx","SortingVisualiser.jsx","SortingAlgorithms/InsertionSort.js","App.js","serviceWorker.js","index.js"],"names":["mergeSortAnimation","a","animations","copyA","slice","mergeSort","startIdx","endIdx","m","Math","floor","i","j","k","push","merge","length","heapSortAnimation","n","arr","arrLen","bubbleDown","heapify","heapSort","heap","heapLen","index","lcIndex","rcIndex","biggerIndex","Caption","props","state","title","description","time","space","this","resetCard","prevProps","currentCaption","heapCard","mergeCard","insertionCard","setState","Card","className","Body","Title","Subtitle","Text","React","Component","COLOR1","SortingVisualiser","array","sliderValue","genArray","min","max","random","arrayBars","document","getElementsByClassName","bar1Idx","bar1Height","bar2Idx","bar2Height","bar1Style","style","bar2Style","setTimeout","height","color","backgroundColor","Promise","resolve","newHeight","cur","temp","insertionSort","insertionSortAnimation","currentVal","getElementById","value","truth","disabled","Container","fluid","Row","Navbar","collapseOnSelect","expand","bg","variant","Brand","href","NavItem","onClick","id","Icon","type","defaultValue","onInput","sliderHandler","step","Toggle","Collapse","Nav","captionHandler","then","disableNav","map","width","key","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","navigator","serviceWorker","ready","registration","unregister","catch","error","console","message"],"mappings":"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","file":"static/js/main.875dd1ab.chunk.js","sourcesContent":["export function mergeSortAnimation(a){\r\n  const animations = [];\r\n  const copyA = a.slice();\r\n  mergeSort(a, 0, a.length - 1, copyA, animations);\r\n  return animations\r\n}\r\n\r\n\r\nfunction mergeSort(a, startIdx, endIdx, copyA, animations){\r\n  // Track original array a's index, and modify animations (a constant) in place, no need to return sorted array\r\n  // Don't slice original array into left and right, just mark the start and end index of original array\r\n  \r\n  if (endIdx === startIdx){\r\n    return \r\n  }\r\n  \r\n  const m = Math.floor((startIdx + endIdx)/2);\r\n  // recurse root->left->right->merge root, then go back up to recurse right node adjacent to merged root \r\n  // copyA is first parameter of mergeSort so that the unmodified copyA is passed as original array to merge function\r\n  mergeSort(copyA, startIdx, m, a, animations);\r\n\r\n  mergeSort(copyA, m + 1, endIdx, a, animations);\r\n\r\n  merge(a, startIdx, m, endIdx, copyA, animations);\r\n\r\n\r\n}\r\n\r\nfunction merge(a, startIdx, m, endIdx, copyA, animations){\r\n  // first index of \"left slice\", incremented if left slice's first element is smaller\r\n  let i = startIdx;\r\n  // first index of \"right slice\", increment if right slice's first element is smaller\r\n  let j = m + 1;\r\n  // front of sorted, merged slices, incremented every loop to be always at front\r\n  let k = startIdx;\r\n  // iterate through \"left slice\" and \"right slice\" have been iterated \r\n  while (i <= m && j <= endIdx){\r\n    // push indices being compared to change color, and then push again to revert color\r\n    animations.push([i, j]);\r\n    animations.push([i, j]);\r\n    // compare copyA's (unmodified array) first element in \"left\" and \"right\", if left one is smaller\r\n    if (copyA[i] <= copyA[j]){\r\n      // push height to make animation look like swapping heights, ie. modifies a's value at index k with the smaller of compared values\r\n      animations.push([k, copyA[i]]);\r\n      // modify original array\r\n      a[k] = copyA[i];\r\n      // increment indices\r\n      k++;\r\n      i++;\r\n    } else {\r\n      animations.push([k, copyA[j]]);\r\n      a[k] = copyA[j];\r\n      k++;\r\n      j++;\r\n    }\r\n  }\r\n  // add animation for any leftover elements in either \"left\" or \"right\" slices respectively\r\n  while (i <= m){\r\n    // just change color of index i\r\n    animations.push([i, i]);\r\n    animations.push([i, i]);\r\n    animations.push([k, copyA[i]]);\r\n    a[k] = copyA[i];\r\n    k++;\r\n    i++;\r\n  }\r\n\r\n  while (j <= endIdx){\r\n    // just change color of index j\r\n    animations.push([j, j]);\r\n    animations.push([j, j]);\r\n    animations.push([k, copyA[j]]);\r\n    a[k] = copyA[j];\r\n    k++;\r\n    j++;\r\n  }\r\n}\r\n\r\n\r\n// // Original code\r\n// const unsorted = [5, 2, 6, 20, 4, 3, 7, 17, 9, 10]\r\n\r\n// export const mergeSort = a =>{\r\n//   if (a.length <= 1){\r\n//     return a\r\n//   }\r\n//   // Simultaneously evaluate m, l, r\r\n//   let m = Math.floor(a.length / 2 ),\r\n//       l = mergeSort(a.slice(0, m)),\r\n//       r = mergeSort(a.slice(m))\r\n\r\n//   // Merge sorted arrays\r\n//   return merge(l, r)\r\n//   }\r\n\r\n\r\n// function merge(l, r){\r\n//   let sorted = []\r\n//   while (l.length > 0 && r.length > 0){\r\n//     if (l[0]  < r[0]){\r\n//       sorted.push(l.shift())\r\n//     } else {\r\n//       sorted.push(r.shift())\r\n//     }\r\n//   }\r\n//   // add leftover elements in either l or r with sorted array\r\n//   return sorted.concat(l.slice().concat(r.slice()))\r\n// }\r\n\r\n// console.log(\"Unsorted array: \", unsorted)\r\n// console.log(\"Merge sort: \", mergeSort(unsorted))","export function heapSortAnimation(a){\r\n  const animations =[];\r\n  heapSort(a, animations);\r\n  return animations\r\n}\r\n\r\nfunction bubbleDown(heap, heapLen, index, animations){\r\n  // Restore max heap from a specified index down to bottom\r\n  while (index < heapLen){\r\n    // console.log(\"Bubble down from index: \", index);\r\n    // Left child index \r\n    const lcIndex = index * 2 + 1;\r\n    if (lcIndex >= heapLen){\r\n      break;\r\n    }\r\n    //Right child index\r\n    const rcIndex = index * 2 + 2;\r\n\r\n    // Find bigger child between left child and right child (if any)\r\n    const biggerIndex = (rcIndex < heapLen && heap[rcIndex] > heap[lcIndex]) ? rcIndex : lcIndex;\r\n\r\n    if (heap[biggerIndex] > heap[index]){\r\n      // Push indices being swapped to change color (3rd color for bubble down)\r\n      animations.push([4, biggerIndex, index]);\r\n      // Push index and new height of each of the two bars being swapped\r\n      animations.push([2, biggerIndex, heap[index], index, heap[biggerIndex]]);\r\n      // Swap\r\n      // console.log(\"Swap %s and %s\", heap[biggerIndex], heap[index]);\r\n      ;[heap[biggerIndex], heap[index]] = [heap[index], heap[biggerIndex]];\r\n      // Push indices being swapped to revert color\r\n      animations.push([3, biggerIndex, index]);\r\n      index = biggerIndex;\r\n      // console.log(heap);\r\n    } else {\r\n      break\r\n    }\r\n  }\r\n  return heap\r\n}\r\n\r\nfunction heapify(arr, arrLen, animations){\r\n  // Convert an unsorted array to a heap by bubbling down from leaf up to top\r\n  // First index with children is integer division of arrLen by 2, minus 1\r\n  for (let i = Math.floor(arrLen / 2) - 1; i >= 0; i--){\r\n    arr = bubbleDown(arr, arrLen, i, animations);\r\n  }\r\n  return arr\r\n}\r\n\r\nexport function heapSort(a, animations){\r\n  const n = a.length;\r\n  const arr = heapify(a, n, animations);\r\n  // console.log(\"Heapify done: \", arr)\r\n  for (let i = n-1; i>=0; i--){\r\n    // Push indices being swapped to change color\r\n    animations.push([1, i, 0]);\r\n    // Push index and height for each of the two bars being swapped\r\n    animations.push([2, i, arr[0], 0, arr[i]])\r\n    // Move max value at index 0 to the back, which is the sorted arr\r\n    ;[arr[i], arr[0]] = [arr[0], arr[i]];\r\n    // Push indices being swapped to revert color\r\n    animations.push([3, i, 0]);\r\n    // excluded i and after from bubble down since it's the sorted arr in place\r\n    bubbleDown(arr, i, 0, animations);\r\n  }\r\n  return arr\r\n}\r\n\r\n","import React from 'react';\nimport Card from 'react-bootstrap/Card';\n\nclass Caption extends React.Component{\n\n    constructor(props){\n        super(props);\n\n        this.state = {\n            title: \"\",\n            description: \"\",\n            time: \"\",\n            space: \"\",\n        };\n    }\n\n    componentDidMount(){\n        this.resetCard();\n    }\n\n    componentDidUpdate(prevProps){\n        if (prevProps.currentCaption !== this.props.currentCaption){\n            if (this.props.currentCaption === \"Heap Sort\"){\n                this.heapCard()\n            } else if (this.props.currentCaption === \"Merge Sort\"){\n               this.mergeCard()\n            } else if (this.props.currentCaption === \"Insertion Sort\"){\n                this.insertionCard()\n            } else{\n                this.resetCard()\n            }\n        }\n    }\n\n    resetCard(){\n        this.setState({\n            title: \"Welcome to Sorting Visualiser!\",\n            description: \"Click 'Generate array' to generate a random array.\" ,\n            time: \"Use the slider to adjust the speed of animation and size of array.\",\n            space: \"Click 'Heap Sort', 'Merge Sort' or 'Insertion Sort' in the top menu to start sorting!\",\n        })\n    }\n    \n    heapCard(){\n        this.setState({\n            title: \"Heap Sort\",\n            description: \"It is called 'heap' sort because a 'heap' data structure is implemented to repeatedly choose the largest item more quickly.\",\n            time: \"Time complexity: O(n log(n))\",\n            space: \"Space complexity: O(1)\",\n        })\n    }\n\n    mergeCard(){\n        this.setState({\n            title: \"Merge Sort\",\n            description: \"Merge sort is a divide-and-conquer algorithm that recursively splits the array in half and sorts each half, and then merge the sorted halves.\",\n            time: \"Time complexity: O(n log(n)) \",\n            space: \"Space complexity: O(n)\",\n        })       \n    }\n\n    insertionCard(){\n        this.setState({\n            title: \"Insertion Sort\",\n            description: \"Insertion sort works by inserting elements from an unsorted array to a sorted array. This is also how most people sort a poker hand.\",\n            time: \"Time complexity: O(n^2)\" ,\n            space: \"Space complexity: O(1)\",\n        })       \n    }\n\n    render(){\n        return(\n            <Card className=\"center card-size\">\n            <Card.Body>\n                <Card.Title>\n                    {this.state.title}\n                </Card.Title>\n                <Card.Subtitle className=\"mb-2 text-muted card-font\">\n                    {this.state.description}\n                </Card.Subtitle>\n                <Card.Text className=\"card-font\">\n                    {this.state.time}\n                </Card.Text>\n                <Card.Text className=\"card-font\">\n                    {this.state.space}\n                </Card.Text>\n            </Card.Body>\n        </Card>\n        )\n    }\n}\n\n\n\nexport default Caption","import React from 'react';\nimport { mergeSortAnimation } from './SortingAlgorithms/MergeSort';\nimport { insertionSortAnimation } from './SortingAlgorithms/InsertionSort';\nimport { heapSortAnimation } from './SortingAlgorithms/HeapSort';\nimport Caption from './Caption';\nimport Nav from 'react-bootstrap/Nav';\nimport Navbar from 'react-bootstrap/Navbar';\nimport NavItem from 'react-bootstrap/NavItem';\nimport Container from 'react-bootstrap/Container';\nimport Row from 'react-bootstrap/Row';\nimport Icon from '@material-ui/core/Icon';\n\nconst COLOR1 = \"rgb(52, 230, 170)\";\nconst COLOR2 = \"blueviolet\";\nconst COLOR3 = \"orangered\";\nconst ANIMATION_SPEED = 50;\nconst NUMBER_OF_BAR = 10;\n\nclass SortingVisualiser extends React.Component{\n\n    constructor(props){\n        super(props);\n\n        this.state = {\n            array: [],\n            currentCaption: \"\",\n            sliderValue: \"5\",\n        };\n    }\n\n    componentDidMount(){\n        this.genArray();\n    }\n\n    genArray(){\n        const array = []\n        for (let i = 0; i < NUMBER_OF_BAR*this.state.sliderValue; i++){\n            array.push(randomIntFromInterval(5,1000));\n        }\n        this.setState({array:array})\n    }\n\n    heapSort(){\n        const animations = heapSortAnimation(this.state.array);\n        const arrayBars = document.getElementsByClassName('array-bar');\n        for (let i = 0; i < animations.length; i++){\n            if (animations[i][0] === 2){   \n                const [bar1Idx, bar1Height, bar2Idx, bar2Height] = animations[i].slice(1);\n                const bar1Style = arrayBars[bar1Idx].style;\n                const bar2Style = arrayBars[bar2Idx].style;\n                setTimeout(()=>{\n                    bar1Style.height = `${bar1Height/10}%`;\n                    bar2Style.height = `${bar2Height/10}%`;\n                }, i * ANIMATION_SPEED * 1/this.state.sliderValue)                           \n        } else{\n            const [bar1Idx, bar2Idx] = animations[i].slice(1)\n            const bar1Style = arrayBars[bar1Idx].style;\n            const bar2Style = arrayBars[bar2Idx].style;\n            let color;\n            if (animations[i][0] === 1){\n                color = COLOR2;\n            } else if (animations[i][0] === 3){\n                color = COLOR1;\n            } else{\n                color = COLOR3;\n            }\n            setTimeout(()=>{\n                bar1Style.backgroundColor = color;\n                bar2Style.backgroundColor = color;\n            }, i * ANIMATION_SPEED * 1/this.state.sliderValue); \n            }                        \n        } \n\n        return new Promise((resolve) => { \n            // Setting a delay equal to time needed for animation to play\n            setTimeout(resolve, animations.length * ANIMATION_SPEED * 1/this.state.sliderValue); })\n    }\n\n    mergeSort(){\n        const animations = mergeSortAnimation(this.state.array);\n        const arrayBars = document.getElementsByClassName('array-bar');\n        for (let i = 0; i < animations.length; i++){\n            if (i % 3 === 0 || i % 3 === 1){\n                // Change color or revert color animation\n                const [bar1Idx, bar2Idx] = animations[i];\n                const bar1Style = arrayBars[bar1Idx].style;\n                const bar2Style = arrayBars[bar2Idx].style;\n                const color = i % 3 === 0 ? COLOR2 : COLOR1; \n                // set time out so that animation shows one by one instead of all at once\n                setTimeout(()=>{\n                    bar1Style.backgroundColor = color;\n                    bar2Style.backgroundColor = color;\n                }, i * ANIMATION_SPEED * 1/this.state.sliderValue);\n\n            } else {\n                // Change height\n                const [bar1Idx, newHeight] = animations[i];\n                const bar1Style = arrayBars[bar1Idx].style;\n                setTimeout(()=>{\n                    bar1Style.height = `${newHeight/10}%`;\n                }, i * ANIMATION_SPEED * 1/this.state.sliderValue)\n            }\n        }\n\n        return new Promise((resolve) => { \n            // Setting a delay equal to time needed for animation to play\n            setTimeout(resolve, animations.length * ANIMATION_SPEED * 1/this.state.sliderValue); })\n    }\n\n    insertionSort(){\n        const animations = insertionSortAnimation(this.state.array);\n        const arrayBars = document.getElementsByClassName('array-bar');\n        for (let i = 0; i < animations.length; i++){\n            if (animations[i][0] === 2 ) {\n                const [bar1Idx, bar1Height, bar2Idx, bar2Height] = animations[i].slice(1);\n                const bar1Style = arrayBars[bar1Idx].style;\n                const bar2Style = arrayBars[bar2Idx].style;\n                setTimeout(()=>{\n                    bar1Style.height = `${bar1Height/10}%`;\n                    bar2Style.height = `${bar2Height/10}%`;\n                }, i * ANIMATION_SPEED * 1/this.state.sliderValue)               \n            } else{\n                const [bar1Idx, bar2Idx] = animations[i].slice(1)\n                const bar1Style = arrayBars[bar1Idx].style;\n                const bar2Style = arrayBars[bar2Idx].style;\n                let color;\n                if (animations[i][0] === 1){\n                    color = COLOR2;\n                } else if (animations[i][0] === 3){\n                    color = COLOR1;\n                } else{\n                    color = COLOR3;\n                }\n                setTimeout(()=>{\n                    bar1Style.backgroundColor = color\n                    bar2Style.backgroundColor = color\n                }, i * ANIMATION_SPEED * 1/this.state.sliderValue);                 \n            } \n        }\n\n        return new Promise((resolve) => { \n            // Setting a delay equal to time needed for animation to play\n            setTimeout(resolve, animations.length * ANIMATION_SPEED * 1/this.state.sliderValue); })\n\n    }\n\n    captionHandler(currentCaption){\n        // Update this state's caption property in order to update props of child component <Caption>\n        this.setState({currentCaption: currentCaption})\n        // when done, return promise to ensure set state precedes method for animations\n        return Promise.resolve(true);\n    }\n\n    sliderHandler(){\n        const input = document.getElementById(\"mySlider\");\n        const currentVal = input.value;\n        this.setState({sliderValue: currentVal}); \n        this.genArray();      \n    }\n\n    disableNav(truth){\n        document.getElementById(\"myButton\").disabled = truth;\n        document.getElementById(\"mySlider\").disabled = truth;  \n        document.getElementById(\"heapBtn\").disabled = truth;\n        document.getElementById(\"mergeBtn\").disabled = truth;\n        document.getElementById(\"insertionBtn\").disabled = truth;\n    }\n\n    render(){\n        var disableLink = false;\n        return(\n            <Container fluid>\n                <Row>\n                <Navbar collapseOnSelect expand=\"md\" bg=\"dark\" variant=\"dark\" className=\"full-width\">\n                    <Navbar.Brand href=\".\" >\n                        Sorting Visualiser\n                    </Navbar.Brand>\n                    <NavItem>\n                        <button className=\"btn btn-primary\" onClick={()=>this.genArray()} id=\"myButton\">\n                            Generate array\n                        </button>      \n                    </NavItem>\n                    <NavItem className=\"cn-align\">\n                        <Icon style={{color: `rgb(52, 230, 170)`}} className=\"center\">speed</Icon>\n                        <input id=\"mySlider\" type=\"range\" min=\"1\" max=\"10\" defaultValue=\"5\" \n                            onInput={()=>this.sliderHandler()} step=\"1\"/>\n                    </NavItem>\n                    <Navbar.Toggle/>\n                    <Navbar.Collapse>\n                        <Nav>\n                            <NavItem className=\"cn-align\">\n                                <button className=\"nav-btn btn\" id=\"heapBtn\" onClick={()=>{\n                                    this.captionHandler(\"Heap Sort\").then(()=>{\n                                        this.disableNav(true);\n                                        // Run method for animations\n                                        this.heapSort().then(()=>{\n                                            this.disableNav(false);\n                                        }) \n                                    })\n                                    }}>\n                                    Heap Sort\n                                </button>\n                            </NavItem>\n    \n                            <NavItem className=\"cn-align\">\n                                <button className=\"nav-btn btn\" id=\"mergeBtn\" onClick={()=>{\n                                    this.captionHandler(\"Merge Sort\").then(()=>{\n                                        this.disableNav(true);\n                                        // Run method for animations\n                                        this.mergeSort().then(()=>{\n                                            this.disableNav(false);\n                                        }) \n                                    })\n                                    }}>\n                                    Merge Sort\n                                </button>\n                            </NavItem>\n\n                            <NavItem className=\"cn-align\">\n                                <button className=\"nav-btn btn\" id=\"insertionBtn\" onClick={()=>{\n                                    this.captionHandler(\"Insertion Sort\").then(()=>{\n                                        this.disableNav(true);\n                                        // Run method for animations\n                                        this.insertionSort().then(()=>{\n                                            this.disableNav(false);\n                                        }) \n                                    })\n                                    }}>\n                                    Insertion Sort\n                                </button>\n                            </NavItem>\n                        </Nav>\n                    </Navbar.Collapse>\n                </Navbar>  \n                </Row>\n                <Row>           \n                    <Caption currentCaption={this.state.currentCaption} ></Caption>\n                </Row> \n                <Row className=\"row mt-5 center\"> \n                    <div className=\"array-container center\">\n                        {this.state.array.map((value, index)=>(\n                            <div \n                            className=\"array-bar\" \n                            style={{height: `${value/10}%`,\n                                    width: `${0.5*100/NUMBER_OF_BAR}%`,\n                                    backgroundColor: COLOR1 }}\n                            // assigning the key property ensures DOM reinitialises the element\n                            key={index}>\n                            </div>\n                        ))}\n                    </div>\n                </Row>\n\n                \n\n            </Container>\n        );\n    }\n\n}\n\nfunction randomIntFromInterval(min, max){\n    return Math.floor(Math.random() * (max - min + 1) + min)\n}\n\nexport default SortingVisualiser","export function insertionSortAnimation(a){\r\n  const animations = [];\r\n  insertionSort(a, animations);\r\n  return animations\r\n}\r\n\r\n\r\nfunction insertionSort(a, animations){\r\n  let cur, temp;\r\n  for (let i = 1; i < a.length; i++){\r\n    // first element of unsorted array \r\n    cur = a[i];\r\n    // marker of first element of unsorted array \r\n    temp = i;\r\n    for (let j = i-1; j >= 0; j--){\r\n      // push indices being compared to change color\r\n      animations.push([4, i, j]);     \r\n      // push indices being compared to revert color\r\n      animations.push([3, i, j]);   \r\n      if (cur < a[j]){\r\n        // push indices being compared to change color\r\n        animations.push([1, temp, j]);\r\n        // push index and new height for each of the two bars being compared and swapped\r\n        animations.push([2, temp, a[j], j, a[temp]]);\r\n        [a[temp], a[j]] = [a[j], a[temp]];\r\n        // push indices being compared to revert color\r\n        animations.push([3, temp, j]);   \r\n        temp = j;\r\n      } else {\r\n        break;\r\n      }\r\n\r\n    }\r\n  }\r\n  return a\r\n}\r\n\r\n","import React from 'react';\n// import logo from './logo.svg';\nimport './App.css';\nimport SortingVisualiser from './SortingVisualiser';\n\nfunction App() {\n  return (\n    <SortingVisualiser></SortingVisualiser>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport './custom.scss';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}